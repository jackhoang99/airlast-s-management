import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "npm:@supabase/supabase-js";
import { PDFDocument, rgb, StandardFonts } from "npm:pdf-lib";
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};
serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", {
      headers: corsHeaders,
    });
  }
  try {
    const supabaseUrl = Deno.env.get("SUPABASE_URL") || "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || "";
    if (!supabaseUrl || !supabaseServiceKey) {
      throw new Error("Supabase environment variables are not set");
    }
    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    const {
      jobId,
      quoteType,
      quoteNumber,
      templateId,
      jobData,
      inspectionData,
      replacementData,
      jobItems,
      replacementDataById,
    } = await req.json();
    // Log received data for debugging
    console.log("Received data:", {
      jobId,
      quoteType,
      quoteNumber,
      templateId,
      hasJobData: !!jobData,
      inspectionCount: Array.isArray(inspectionData)
        ? inspectionData.length
        : 0,
      hasReplacementData: !!replacementData,
      hasReplacementDataById:
        !!replacementDataById &&
        Object.keys(replacementDataById || {}).length > 0,
    });
    if (!jobId || !quoteType) {
      return new Response(
        JSON.stringify({
          error: "Missing required fields: jobId and quoteType",
        }),
        {
          status: 400,
          headers: {
            ...corsHeaders,
            "Content-Type": "application/json",
          },
        }
      );
    }
    // Fetch template if templateId is provided
    let templateData = null;
    if (templateId) {
      const { data: fetchedTemplate, error: templateError } = await supabase
        .from("quote_templates")
        .select("*")
        .eq("id", templateId)
        .single();
      if (templateError) {
        console.log("Template not found, using default template");
      } else {
        templateData = fetchedTemplate;
      }
    }

    // Use default template if no template found
    if (!templateData || !templateData.template_data?.fileUrl) {
      console.log("Using default template for quote generation");
      // Create a simple default template structure
      templateData = {
        template_data: {
          fileUrl: "https://example.com/default-template.pdf", // This will be ignored
          preservedPages: [1],
        },
      };
    }
    // Fetch template PDF if available, otherwise create a new document
    let pdfDoc;
    if (
      templateData.template_data.fileUrl &&
      templateData.template_data.fileUrl !==
        "https://example.com/default-template.pdf"
    ) {
      const tplRes = await fetch(templateData.template_data.fileUrl);
      if (!tplRes.ok) {
        console.log("Failed to fetch template PDF, creating new document");
        pdfDoc = await PDFDocument.create();
      } else {
        const tplBytes = await tplRes.arrayBuffer();
        pdfDoc = await PDFDocument.load(tplBytes);
      }
    } else {
      console.log("Creating new PDF document without template");
      pdfDoc = await PDFDocument.create();
    }
    const newPdfDoc = await PDFDocument.create();
    // Get preserved pages if template exists
    const preserved = templateData?.template_data?.preservedPages || [1];
    const sorted = [...preserved].sort((a, b) => a - b);

    // Find insertion point
    let insertPos = sorted.length;
    for (let i = 0; i < sorted.length - 1; i++) {
      if (sorted[i + 1] - sorted[i] > 1) {
        insertPos = i + 1;
        break;
      }
    }

    // Only copy preserved pages if we have a template with pages
    if (pdfDoc.getPageCount() > 0) {
      // Copy first set of preserved pages
      for (let i = 0; i < insertPos; i++) {
        const p = sorted[i];
        if (p > 0 && p <= pdfDoc.getPageCount()) {
          const [copied] = await newPdfDoc.copyPages(pdfDoc, [p - 1]);
          newPdfDoc.addPage(copied);
        }
      }
    }
    // Create dynamic page
    let dynamicPage = newPdfDoc.addPage();
    // Add background image with error handling
    let bgImage = null;
    try {
      const bgUrl =
        "https://ekxkjnygupehzpoyojwq.supabase.co/storage/v1/object/public/background-image//hvac-background.png";
      const bgRes = await fetch(bgUrl);
      if (bgRes.ok) {
        const bgBytes = await bgRes.arrayBuffer();
        bgImage = await newPdfDoc.embedPng(bgBytes);
      } else {
        console.log(
          "Background image not available, proceeding without background"
        );
      }
    } catch (error) {
      console.log("Error loading background image:", error);
    }

    const { width, height } = dynamicPage.getSize();

    // Draw background image if available
    if (bgImage) {
      dynamicPage.drawImage(bgImage, {
        x: 0,
        y: 0,
        width,
        height,
      });
    }
    // Set up fonts and layout
    const font = await newPdfDoc.embedFont(StandardFonts.Helvetica);
    const bold = await newPdfDoc.embedFont(StandardFonts.HelveticaBold);
    const fontSize = 12;
    const lineHeight = fontSize * 1.2;
    const margin = 50;
    const minY = 100; // Minimum Y position before creating a new page
    let y = height - 80;
    // Draw header
    dynamicPage.drawText(`${quoteType.toUpperCase()} QUOTE`, {
      x: margin,
      y,
      size: 24,
      font: bold,
      color: rgb(0, 0, 0),
    });
    y -= 40;
    // Draw quote info
    dynamicPage.drawText(`Quote #: ${quoteNumber}`, {
      x: margin,
      y,
      size: fontSize,
      font,
    });
    y -= lineHeight;
    // Fix job number display - handle different data structures
    const jobNumber = jobData?.number || jobData?.job?.number || jobId || "N/A";
    dynamicPage.drawText(`Job #: ${jobNumber}`, {
      x: margin,
      y,
      size: fontSize,
      font,
    });
    y -= lineHeight;
    dynamicPage.drawText(`Date: ${new Date().toLocaleDateString()}`, {
      x: margin,
      y,
      size: fontSize,
      font,
    });
    y -= lineHeight * 2;
    // Draw customer info
    if (jobData?.locations) {
      dynamicPage.drawText("Customer:", {
        x: margin,
        y,
        size: fontSize + 2,
        font: bold,
      });
      y -= lineHeight;
      dynamicPage.drawText(jobData.locations.companies?.name || "", {
        x: margin,
        y,
        size: fontSize,
        font,
      });
      y -= lineHeight;
      dynamicPage.drawText(jobData.locations.name || "", {
        x: margin,
        y,
        size: fontSize,
        font,
      });
      y -= lineHeight;
      dynamicPage.drawText(jobData.locations.address || "", {
        x: margin,
        y,
        size: fontSize,
        font,
      });
      y -= lineHeight;
      dynamicPage.drawText(
        `${jobData.locations.city || ""}, ${jobData.locations.state || ""} ${
          jobData.locations.zip || ""
        }`,
        {
          x: margin,
          y,
          size: fontSize,
          font,
        }
      );
      // Add unit information if available
      if (jobData.units) {
        y -= lineHeight;
        dynamicPage.drawText(`Unit: ${jobData.units.unit_number || ""}`, {
          x: margin,
          y,
          size: fontSize,
          font,
        });
      }
      y -= lineHeight * 2;
    }
    // Note: Inspection Results section removed as requested - only Inspection Summary will be shown
    // Process replacement data
    let replacementsToProcess = [];
    if (quoteType === "replacement") {
      // Check if replacementDataById is provided in the request (this is the new format with multiple replacements)
      if (replacementDataById && Object.keys(replacementDataById).length > 0) {
        console.log(
          "Using replacementDataById with keys:",
          Object.keys(replacementDataById)
        );
        // Convert the object to an array for processing
        replacementsToProcess = Object.entries(replacementDataById).map(
          ([key, data], index) => ({
            ...data,
            replacementNumber: index + 1,
            created_at: data.created_at || new Date().toISOString(),
          })
        );
      } else if (Array.isArray(replacementData) && replacementData.length > 0) {
        console.log(
          "Using array replacementData with length:",
          replacementData.length
        );
        replacementsToProcess = replacementData.map((data, index) => ({
          ...data,
          replacementNumber: index + 1,
          created_at: data.created_at || new Date().toISOString(),
        }));
      } else if (replacementData && typeof replacementData === "object") {
        console.log("Using single replacementData object");
        replacementsToProcess = [
          {
            ...replacementData,
            replacementNumber: 1,
            created_at: replacementData.created_at || new Date().toISOString(),
          },
        ];
      } else {
        console.log("Fetching replacement data from database");
        // Fetch replacement data for this job
        const { data: fetchedReplacements, error: fetchError } = await supabase
          .from("job_replacements")
          .select("*")
          .eq("job_id", jobId);
        if (
          !fetchError &&
          fetchedReplacements &&
          fetchedReplacements.length > 0
        ) {
          replacementsToProcess = fetchedReplacements.map((data, index) => ({
            ...data,
            replacementNumber: index + 1,
            created_at: data.created_at || new Date().toISOString(),
          }));
        }
      }
    } else if (quoteType === "repair") {
      // Use job items for repair quotes
      if (Array.isArray(jobItems) && jobItems.length > 0) {
        // We'll handle this separately below
      }
    }
    // Check if we need a new page
    if (y < 200) {
      dynamicPage = newPdfDoc.addPage();
      y = height - margin;
      // Add background to new page if available
      if (bgImage) {
        dynamicPage.drawImage(bgImage, {
          x: 0,
          y: 0,
          width,
          height,
        });
      }
    }
    // Draw replacement summary header (only for replacement quotes)
    if (quoteType === "replacement") {
      dynamicPage.drawText("Replacement Summary:", {
        x: margin,
        y,
        size: fontSize + 2,
        font: bold,
      });
      y -= lineHeight * 2;
    }

    // Process each replacement entry
    let combinedTotal = 0;
    if (quoteType === "replacement" && replacementsToProcess.length > 0) {
      console.log(
        `Processing ${replacementsToProcess.length} replacement options`
      );

      // If multiple replacements, show them as a consolidated list
      if (replacementsToProcess.length > 1) {
        // Draw consolidated header
        dynamicPage.drawText("Multiple Replacement Options:", {
          x: margin,
          y,
          size: fontSize + 1,
          font: bold,
        });
        y -= lineHeight * 1.5;

        // Show each replacement as a numbered option
        for (let i = 0; i < replacementsToProcess.length; i++) {
          let entry = replacementsToProcess[i];
          const totalCost = Number(entry.totalCost || entry.total_cost || 0);
          combinedTotal += totalCost;

          // Draw replacement option header
          dynamicPage.drawText(
            `Option ${entry.replacementNumber}: $${totalCost.toLocaleString()}`,
            {
              x: margin,
              y,
              size: fontSize,
              font: bold,
            }
          );
          y -= lineHeight;

          // Show key components for this option
          const components = [];
          if (entry.labor && Number(entry.labor) > 0) {
            components.push(`Labor: $${Number(entry.labor).toLocaleString()}`);
          }
          if (
            entry.refrigerationRecovery &&
            Number(entry.refrigerationRecovery) > 0
          ) {
            components.push(
              `Refrigeration: $${Number(
                entry.refrigerationRecovery
              ).toLocaleString()}`
            );
          }
          if (entry.startUpCosts && Number(entry.startUpCosts) > 0) {
            components.push(
              `Start-up: $${Number(entry.startUpCosts).toLocaleString()}`
            );
          }
          if (entry.removalCost && Number(entry.removalCost) > 0) {
            components.push(
              `Removal: $${Number(entry.removalCost).toLocaleString()}`
            );
          }
          if (entry.thermostatStartup && Number(entry.thermostatStartup) > 0) {
            components.push(
              `Thermostat: $${Number(entry.thermostatStartup).toLocaleString()}`
            );
          }
          if (entry.permitCost && Number(entry.permitCost) > 0) {
            components.push(
              `Permit: $${Number(entry.permitCost).toLocaleString()}`
            );
          }

          // Display components in a compact format
          if (components.length > 0) {
            const componentsText = components.join(" • ");
            dynamicPage.drawText(componentsText, {
              x: margin + 20,
              y,
              size: fontSize - 1,
              font,
            });
            y -= lineHeight;
          }

          // Add requirements if any
          const requirements = [];
          if (entry.needsCrane || entry.needs_crane) {
            requirements.push("Crane Required");
          }
          if (entry.requiresPermit || entry.requires_permit) {
            requirements.push("Permit Required");
          }
          if (entry.requiresBigLadder || entry.requires_big_ladder) {
            requirements.push("Big Ladder Required");
          }

          if (requirements.length > 0) {
            dynamicPage.drawText(`Requirements: ${requirements.join(", ")}`, {
              x: margin + 20,
              y,
              size: fontSize - 1,
              font,
              color: rgb(0.8, 0.4, 0),
            });
            y -= lineHeight;
          }

          y -= lineHeight * 0.5; // Small spacing between options
        }

        // Draw total line
        y -= lineHeight;
        dynamicPage.drawLine({
          start: { x: margin, y: y + 5 },
          end: { x: width - margin, y: y + 5 },
          thickness: 1,
          color: rgb(0.8, 0.8, 0.8),
        });
        y -= lineHeight;

        dynamicPage.drawText("Total Replacement Cost:", {
          x: margin,
          y,
          size: fontSize + 1,
          font: bold,
        });
        dynamicPage.drawText(`$${combinedTotal.toLocaleString()}`, {
          x: width - margin - 100,
          y,
          size: fontSize + 1,
          font: bold,
        });
        y -= lineHeight * 2;
      } else {
        // Single replacement - show detailed breakdown
        let entry = replacementsToProcess[0];
        const totalCost = Number(entry.totalCost || entry.total_cost || 0);
        combinedTotal = totalCost;

        // Draw replacement header
        dynamicPage.drawText("Replacement Details:", {
          x: margin,
          y,
          size: fontSize,
          font: bold,
        });
        dynamicPage.drawText(`$${totalCost.toLocaleString()}`, {
          x: width - margin - 100,
          y,
          size: fontSize,
          font: bold,
        });
        y -= lineHeight;

        // For single replacement, show detailed breakdown
        const components = [];
        if (entry.labor && Number(entry.labor) > 0) {
          components.push(`Labor: $${Number(entry.labor).toLocaleString()}`);
        }
        if (
          entry.refrigerationRecovery &&
          Number(entry.refrigerationRecovery) > 0
        ) {
          components.push(
            `Refrigeration Recovery: $${Number(
              entry.refrigerationRecovery
            ).toLocaleString()}`
          );
        }
        if (entry.startUpCosts && Number(entry.startUpCosts) > 0) {
          components.push(
            `Start Up Costs: $${Number(entry.startUpCosts).toLocaleString()}`
          );
        }
        if (entry.thermostatStartup && Number(entry.thermostatStartup) > 0) {
          components.push(
            `Thermostat Startup: $${Number(
              entry.thermostatStartup
            ).toLocaleString()}`
          );
        }
        if (entry.removalCost && Number(entry.removalCost) > 0) {
          components.push(
            `Removal Cost: $${Number(entry.removalCost).toLocaleString()}`
          );
        }
        if (entry.permitCost && Number(entry.permitCost) > 0) {
          components.push(
            `Permit Cost: $${Number(entry.permitCost).toLocaleString()}`
          );
        }

        // Display components
        if (components.length > 0) {
          for (const component of components) {
            dynamicPage.drawText(`• ${component}`, {
              x: margin + 20,
              y,
              size: fontSize - 1,
              font,
            });
            y -= lineHeight;
          }
        }

        // Add requirements if any
        const requirements = [];
        if (entry.needsCrane || entry.needs_crane) {
          requirements.push("Crane Required");
        }
        if (entry.requiresPermit || entry.requires_permit) {
          requirements.push("Permit Required");
        }
        if (entry.requiresBigLadder || entry.requires_big_ladder) {
          requirements.push("Big Ladder Required");
        }

        if (requirements.length > 0) {
          dynamicPage.drawText(`Requirements: ${requirements.join(", ")}`, {
            x: margin + 20,
            y,
            size: fontSize - 1,
            font,
            color: rgb(0.8, 0.4, 0),
          });
          y -= lineHeight;
        }

        y -= lineHeight;
      }
    }

    // Add inspection results to replacement and repair quotes
    if (
      (quoteType === "replacement" || quoteType === "repair") &&
      Array.isArray(inspectionData) &&
      inspectionData.length > 0
    ) {
      // Check if we need a new page
      if (y < 200) {
        dynamicPage = newPdfDoc.addPage();
        y = height - margin;
        // Add background to new page if available
        if (bgImage) {
          dynamicPage.drawImage(bgImage, {
            x: 0,
            y: 0,
            width,
            height,
          });
        }
      }

      // Draw inspection results header
      dynamicPage.drawText("Inspection Results:", {
        x: margin,
        y,
        size: fontSize + 2,
        font: bold,
      });
      y -= lineHeight * 2;

      // List each inspection with comments
      for (let i = 0; i < inspectionData.length; i++) {
        const insp = inspectionData[i];

        // Check if we need a new page
        if (y < 200) {
          dynamicPage = newPdfDoc.addPage();
          y = height - margin;
          // Add background to new page if available
          if (bgImage) {
            dynamicPage.drawImage(bgImage, {
              x: 0,
              y: 0,
              width,
              height,
            });
          }
        }

        dynamicPage.drawText(`Inspection ${i + 1}:`, {
          x: margin,
          y,
          size: fontSize + 1,
          font: bold,
        });
        y -= lineHeight * 1.5;

        // Show inspection details in a structured format
        const details = [];
        if (insp.model_number) details.push(`Model: ${insp.model_number}`);
        if (insp.serial_number) details.push(`Serial: ${insp.serial_number}`);
        if (insp.age) details.push(`Age: ${insp.age} years`);
        if (insp.tonnage) details.push(`Tonnage: ${insp.tonnage}`);
        if (insp.unit_type) details.push(`Type: ${insp.unit_type}`);
        if (insp.system_type) details.push(`System: ${insp.system_type}`);

        if (details.length > 0) {
          const detailsText = details.join(" • ");
          dynamicPage.drawText(detailsText, {
            x: margin + 20,
            y,
            size: fontSize,
            font,
          });
          y -= lineHeight * 1.2;
        }

        // Show inspection comment if available
        if (insp.comment && insp.comment.trim()) {
          dynamicPage.drawText(`Comment: ${insp.comment}`, {
            x: margin + 20,
            y,
            size: fontSize,
            font,
            color: rgb(0.4, 0.4, 0.4),
          });
          y -= lineHeight * 1.2;
        }

        y -= lineHeight; // Spacing between inspections
      }

      y -= lineHeight; // Final spacing after inspections

      // Add summary comment section if available
      if (
        jobData &&
        jobData.inspection_summary_comment &&
        jobData.inspection_summary_comment.trim()
      ) {
        // Check if we need a new page for the summary comment
        if (y < 150) {
          dynamicPage = newPdfDoc.addPage();
          y = height - margin;
          // Add background to new page if available
          if (bgImage) {
            dynamicPage.drawImage(bgImage, {
              x: 0,
              y: 0,
              width,
              height,
            });
          }
        }

        dynamicPage.drawText("Summary Comment:", {
          x: margin,
          y,
          size: fontSize + 1,
          font: bold,
        });
        y -= lineHeight * 1.5;

        // Split comment into lines if it's too long
        const commentText = jobData.inspection_summary_comment;
        const maxWidth = width - margin * 2;
        const words = commentText.split(" ");
        let currentLine = "";

        for (const word of words) {
          const testLine = currentLine ? `${currentLine} ${word}` : word;
          const testWidth = font.widthOfTextAtSize(testLine, fontSize - 1);

          if (testWidth > maxWidth && currentLine) {
            // Draw current line and start new line
            dynamicPage.drawText(currentLine, {
              x: margin,
              y,
              size: fontSize - 1,
              font,
            });
            y -= lineHeight;
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        // Draw the last line
        if (currentLine) {
          dynamicPage.drawText(currentLine, {
            x: margin,
            y,
            size: fontSize - 1,
            font,
          });
          y -= lineHeight * 2;
        }
      }
    } else if (quoteType === "inspection") {
      // Handle inspection quotes
      console.log("Processing inspection quote");

      // Check if we need a new page
      if (y < 200) {
        dynamicPage = newPdfDoc.addPage();
        y = height - margin;
        // Add background to new page if available
        if (bgImage) {
          dynamicPage.drawImage(bgImage, {
            x: 0,
            y: 0,
            width,
            height,
          });
        }
      }

      // Draw inspection details header
      dynamicPage.drawText("Inspection Details:", {
        x: margin,
        y,
        size: fontSize + 3,
        font: bold,
      });
      y -= lineHeight * 2;

      // Show inspection details
      const inspectionCount = Array.isArray(inspectionData)
        ? inspectionData.length
        : 0;

      if (inspectionCount > 0) {
        // List each inspection with comments
        for (let i = 0; i < inspectionData.length; i++) {
          const insp = inspectionData[i];

          // Check if we need a new page
          if (y < 200) {
            dynamicPage = newPdfDoc.addPage();
            y = height - margin;
            // Add background to new page if available
            if (bgImage) {
              dynamicPage.drawImage(bgImage, {
                x: 0,
                y: 0,
                width,
                height,
              });
            }
          }

          dynamicPage.drawText(`Inspection ${i + 1}:`, {
            x: margin,
            y,
            size: fontSize + 1,
            font: bold,
          });
          y -= lineHeight * 1.5;

          // Show inspection details in a structured format
          const details = [];
          if (insp.model_number) details.push(`Model: ${insp.model_number}`);
          if (insp.serial_number) details.push(`Serial: ${insp.serial_number}`);
          if (insp.age) details.push(`Age: ${insp.age} years`);
          if (insp.tonnage) details.push(`Tonnage: ${insp.tonnage}`);
          if (insp.unit_type) details.push(`Type: ${insp.unit_type}`);
          if (insp.system_type) details.push(`System: ${insp.system_type}`);

          if (details.length > 0) {
            const detailsText = details.join(" • ");
            dynamicPage.drawText(detailsText, {
              x: margin + 20,
              y,
              size: fontSize,
              font,
            });
            y -= lineHeight * 1.2;
          }

          // Show inspection comment if available
          if (insp.comment && insp.comment.trim()) {
            dynamicPage.drawText(`Comment: ${insp.comment}`, {
              x: margin + 20,
              y,
              size: fontSize,
              font,
              color: rgb(0.4, 0.4, 0.4),
            });
            y -= lineHeight * 1.2;
          }

          y -= lineHeight; // Spacing between inspections
        }

        y -= lineHeight; // Final spacing after inspections

        // Add summary comment section if available
        if (
          jobData &&
          jobData.inspection_summary_comment &&
          jobData.inspection_summary_comment.trim()
        ) {
          // Check if we need a new page for the summary comment
          if (y < 150) {
            dynamicPage = newPdfDoc.addPage();
            y = height - margin;
            // Add background to new page if available
            if (bgImage) {
              dynamicPage.drawImage(bgImage, {
                x: 0,
                y: 0,
                width,
                height,
              });
            }
          }

          dynamicPage.drawText("Summary Comment:", {
            x: margin,
            y,
            size: fontSize + 1,
            font: bold,
          });
          y -= lineHeight * 1.5;

          // Split comment into lines if it's too long
          const commentText = jobData.inspection_summary_comment;
          const maxWidth = width - margin * 2;
          const words = commentText.split(" ");
          let currentLine = "";

          for (const word of words) {
            const testLine = currentLine ? `${currentLine} ${word}` : word;
            const testWidth = font.widthOfTextAtSize(testLine, fontSize - 1);

            if (testWidth > maxWidth && currentLine) {
              // Draw current line and start new line
              dynamicPage.drawText(currentLine, {
                x: margin,
                y,
                size: fontSize - 1,
                font,
              });
              y -= lineHeight;
              currentLine = word;
            } else {
              currentLine = testLine;
            }
          }

          // Draw the last line
          if (currentLine) {
            dynamicPage.drawText(currentLine, {
              x: margin,
              y,
              size: fontSize - 1,
              font,
            });
            y -= lineHeight * 2;
          }
        }
      } else {
        // No inspections found
        dynamicPage.drawText("No inspection data available", {
          x: margin,
          y,
          size: fontSize,
          font,
          color: rgb(0.6, 0.6, 0.6),
        });
        y -= lineHeight * 2;
      }
    } else if (quoteType === "pm") {
      // Handle PM quotes
      console.log("Processing PM quote");

      // Check if we need a new page
      if (y < 200) {
        dynamicPage = newPdfDoc.addPage();
        y = height - margin;
        // Add background to new page if available
        if (bgImage) {
          dynamicPage.drawImage(bgImage, {
            x: 0,
            y: 0,
            width,
            height,
          });
        }
      }

      // Draw PM summary header
      dynamicPage.drawText("Preventive Maintenance Summary:", {
        x: margin,
        y,
        size: fontSize + 2,
        font: bold,
      });
      y -= lineHeight * 2;

      // Calculate PM total
      let pmTotal = 0;
      const pmCount = Array.isArray(jobItems) ? jobItems.length : 0;
      const basePMCost = 150; // $150 per PM service
      pmTotal = pmCount > 0 ? pmCount * basePMCost : basePMCost;

      // Show PM details
      dynamicPage.drawText(`Number of PM Services: ${pmCount || 1}`, {
        x: margin,
        y,
        size: fontSize,
        font: bold,
      });
      dynamicPage.drawText(`$${pmTotal.toLocaleString()}`, {
        x: width - margin - 100,
        y,
        size: fontSize,
        font: bold,
      });
      y -= lineHeight;

      // Show cost breakdown
      dynamicPage.drawText(`Cost per PM Service: $${basePMCost}`, {
        x: margin + 20,
        y,
        size: fontSize - 1,
        font,
      });
      y -= lineHeight;

      // Show PM details
      dynamicPage.drawText("PM Service Details:", {
        x: margin,
        y,
        size: fontSize,
        font: bold,
      });
      y -= lineHeight;

      // List PM services
      const pmServices = [
        "Filter replacement and cleaning",
        "System inspection and testing",
        "Performance optimization",
        "Safety checks and maintenance",
        "Documentation and reporting",
      ];

      pmServices.forEach((service, index) => {
        dynamicPage.drawText(`• ${service}`, {
          x: margin + 20,
          y,
          size: fontSize - 1,
          font,
        });
        y -= lineHeight;
      });

      // Show total
      y -= lineHeight;
      dynamicPage.drawLine({
        start: { x: margin, y: y + 5 },
        end: { x: width - margin, y: y + 5 },
        thickness: 1,
        color: rgb(0.8, 0.8, 0.8),
      });
      y -= lineHeight;

      dynamicPage.drawText("Total PM Cost:", {
        x: margin,
        y,
        size: fontSize + 1,
        font: bold,
      });
      dynamicPage.drawText(`$${pmTotal.toLocaleString()}`, {
        x: width - margin - 100,
        y,
        size: fontSize + 1,
        font: bold,
      });
      y -= lineHeight * 2;
    } else if (
      quoteType === "repair" &&
      Array.isArray(jobItems) &&
      jobItems.length > 0
    ) {
      console.log(`Processing repair quote with ${jobItems.length} items`);
      // Check if we need a new page
      if (y < 200) {
        dynamicPage = newPdfDoc.addPage();
        y = height - margin;
        // Add background to new page if available
        if (bgImage) {
          dynamicPage.drawImage(bgImage, {
            x: 0,
            y: 0,
            width,
            height,
          });
        }
      }
      dynamicPage.drawText("Items:", {
        x: margin,
        y,
        size: fontSize + 2,
        font: bold,
      });
      y -= lineHeight * 1.5;
      // Table header
      dynamicPage.drawText("Item", {
        x: margin,
        y,
        size: fontSize,
        font: bold,
      });
      dynamicPage.drawText("Quantity", {
        x: 300,
        y,
        size: fontSize,
        font: bold,
      });
      dynamicPage.drawText("Price", {
        x: 400,
        y,
        size: fontSize,
        font: bold,
      });
      y -= lineHeight;
      let totalAmount = 0;
      // Filter items for repair job (only parts)
      const repairItems = jobItems.filter((item) => item.type === "part");
      console.log(`Found ${repairItems.length} part items for repair quote`);
      for (const item of repairItems) {
        // Check if we need a new page
        if (y < minY) {
          dynamicPage = newPdfDoc.addPage();
          y = height - margin;
          // Add background to new page if available
          if (bgImage) {
            dynamicPage.drawImage(bgImage, {
              x: 0,
              y: 0,
              width,
              height,
            });
          }
          // Redraw table header on new page
          dynamicPage.drawText("Item", {
            x: margin,
            y,
            size: fontSize,
            font: bold,
          });
          dynamicPage.drawText("Quantity", {
            x: 300,
            y,
            size: fontSize,
            font: bold,
          });
          dynamicPage.drawText("Price", {
            x: 400,
            y,
            size: fontSize,
            font: bold,
          });
          y -= lineHeight;
        }
        const name = item.name || "Unknown";
        const quantity = item.quantity || 1;
        const cost = Number(item.total_cost || 0);
        dynamicPage.drawText(name, {
          x: margin,
          y,
          size: fontSize,
          font,
        });
        dynamicPage.drawText(quantity.toString(), {
          x: 300,
          y,
          size: fontSize,
          font,
        });
        dynamicPage.drawText(`$${cost.toFixed(2)}`, {
          x: 400,
          y,
          size: fontSize,
          font,
        });
        totalAmount += cost;
        y -= lineHeight;
      }
      y -= lineHeight;
      dynamicPage.drawText("Total:", {
        x: 300,
        y,
        size: fontSize + 2,
        font: bold,
      });
      dynamicPage.drawText(`$${totalAmount.toFixed(2)}`, {
        x: 400,
        y,
        size: fontSize + 2,
        font: bold,
      });
    }
    // Copy remaining preserved pages
    for (let i = insertPos; i < sorted.length; i++) {
      const p = sorted[i];
      if (p > 0 && p <= pdfDoc.getPageCount()) {
        const [copied] = await newPdfDoc.copyPages(pdfDoc, [p - 1]);
        newPdfDoc.addPage(copied);
      }
    }
    // Save PDF
    const outBytes = await newPdfDoc.save();
    // Upload to storage
    const filePath = `quotes/${jobId}/${quoteType}_${quoteNumber}.pdf`;
    const { error: uploadError } = await supabase.storage
      .from("quotes")
      .upload(filePath, outBytes, {
        contentType: "application/pdf",
        upsert: true,
      });
    if (uploadError) throw new Error(`Upload error: ${uploadError.message}`);
    // Create signed URL
    const { data: signed, error: urlError } = await supabase.storage
      .from("quotes")
      .createSignedUrl(filePath, 3600);
    if (urlError) throw new Error(`Signed URL error: ${urlError.message}`);
    return new Response(
      JSON.stringify({
        success: true,
        pdfUrl: signed.signedUrl,
        quoteNumber,
        quoteType,
      }),
      {
        status: 200,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      }
    );
  } catch (err) {
    console.error("Error generating PDF:", err);
    return new Response(
      JSON.stringify({
        error: err.message || "Unknown error",
      }),
      {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json",
        },
      }
    );
  }
});
